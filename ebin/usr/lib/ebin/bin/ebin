#!/usr/bin/python
# Builds a new binary ebuild, and regenerates the binary index ebuild
# Jacob Godserv <jacobgodserv@gmail.com>

import math
import os
import portage
import portage.versions
import re
import sys
from _emerge.main import load_emerge_config
from _emerge.depgraph import backtrack_depgraph
from _emerge.create_depgraph_params import create_depgraph_params
from binascii import crc32
from portage import xpak
from portage import config

ebin_lib=os.environ["ROOT"]+"/usr/lib/ebin/"

def usage():
	print 'Usage: '+sys.argv[0]+' <ebin_ebuild_overlay> <new_xpak || =cat/pkg-ver>'

def read_group_list(ebuild_path):
	if not os.path.exists(ebuild_path):
		return []
	
	f=open(ebuild_path, 'r')
	
	group_list=[]
	group={}
	group_begin=False
	pkg_begin=False
	
	use_combo_re = re.compile('## USE (.*)')
	depend_combo_re = re.compile('## DEPEND (.*)')
	ebuild_re = re.compile('## EBUILD (.*)')
	for line in f:
		if line.find('## BEGIN spec') is 0:
			group_begin=True
		elif not group_begin:
			continue
		elif line.find('## END spec') is 0:
			group_begin=False
			break
		
		elif line.find('## BEGIN group') is 0:
			if group:
				group_list.append(group)
			group={}
			pkg_begin=True
		elif not pkg_begin:
			continue
		elif line.find('## END group') is 0:
			pkg_begin=False
			if group:
				group_list.append(group)
			group={}
			
		elif line.find('## USE') is 0:
			if not group.get('use_combos'):
				group['use_combos'] = []
			group['use_combos'].append(use_combo_re.match(line).group(1))
		elif line.find('## DEPEND') is 0:
			if not group.get('depend_combos'):
				group['depend_combos'] = []
			group['depend_combos'].append(depend_combo_re.match(line).group(1))
		elif line.find('## EBUILD') is 0:
			group['ebuild'] = ebuild_re.match(line).group(1)
			
		else:
			continue
	
	f.close()
	
	if group_begin:
		print('Warning: group begun, but not ended')
	if pkg_begin:
		print('Warning: pkg begun, but not ended')
	
	return group_list

def generate_version_hash(package_version):
	return str(int(math.fabs(crc32(package_version))))

def generate_new_ebuild_name(package_name, package_version, group_list):
	ebuild_count = len(group_list)
	ebuild_name = None
	is_unique = False
	while not is_unique:
		ebuild_name = package_name+'-'+generate_version_hash(package_version)+'-r'+str(ebuild_count)
		is_unique = True
		for group in group_list:
			if ebuild_name is group['ebuild']:
				is_unique = False
				break
		
		if is_unique is False:
			ebuild_count+=1
	
	return ebuild_name

def build_spec(group_list):
	spec = '## BEGIN spec\n'
	for group in group_list:
		spec += '## BEGIN group\n'
		for use_combo in group['use_combos']:
			spec += '## USE '+use_combo+'\n'
			spec += 'if [[ "${USE}" == \''+use_combo+'\' ]]; then\n'
			spec += '	RDEPEND="='+group['ebuild']+'"\n'
			spec += '	IS_XPAK="yes"\n'
			spec += 'fi\n'
		for depend_combo in group['depend_combos']:
			spec += '## DEPEND '+depend_combo+'\n'
		spec += '## EBUILD '+group['ebuild']+'\n'
		spec += '## END group\n'
	spec += '## END spec\n'
	return spec
	
def build_use_check_code(uses):
	use_list = uses.split(' ')
	if not use_list:
		return ''
	
	code = 'if '
	for use in use_list:
		code += 'use \''+use+'\'; '
	code += 'then\n'
	code += '	IS_XPAK="1" # ok\n'
	code += 'else\n'
	code += '	ewarn "The USE flags don\'t match the binary about to be emerged!"\n'
	code += '	ewarn "Cancel now unless you know what you\'re doing!"\n'
	code += '	epause\n'
	code += 'fi\n'
	return code

def lookup_deps(package, settings):

	myopts = {}
	myopts["--onlydeps"] = True
	myopts["--emptytree"] = True
	myfiles = ['='+package]
	myaction = None
	spinner = None
	myparams = create_depgraph_params(myopts, myaction)
	success, mydepgraph, favorites = backtrack_depgraph(
		settings, trees, myopts, myparams, None, myfiles, spinner)
	
	if not success:
		return None
	
	package_list = ''
	found_nonreinstallss = False
	for package in mydepgraph.altlist():
		package_list += ' ='+package.cpv
		if not trees[settings["ROOT"]]["vartree"].dbapi.cpv_exists(package.cpv):
			print package.cpv
			found_nonreinstallss = True
	
	return package_list, found_nonreinstallss


if len(sys.argv) is not 3:
	usage()
	exit(1)

settings, trees, mtimedb = load_emerge_config()

ebin_ebuild_overlay = sys.argv[1]
new_xpak = sys.argv[2]

if new_xpak[0] is "=":
	new_xpak = new_xpak[1:]
	from portage.dbapi.bintree import binarytree
	binarytree = binarytree(settings["ROOT"], settings["PKGDIR"])
	new_xpak = binarytree.getname(new_xpak)

new_xpak_index = xpak.tbz2(new_xpak).getboth()

category = xpak.getitem(new_xpak_index, 'CATEGORY').strip()
package = xpak.getitem(new_xpak_index, 'PF').strip()
package_split = portage.versions.catpkgsplit(package)
package_name = package_split[1]
package_version = package[len(package_name+"-"):]

ebin_ebuild = portage.os.path.join(ebin_ebuild_overlay, category, package_name, package+'.ebuild')
group_list = read_group_list(ebin_ebuild)

strict_depend, found_nonreinstallss = lookup_deps(package, settings)
if strict_depend is None:
	print "Failed to lookup strict dependencies for " + package
	exit(2)
elif found_nonreinstallss:
	print "Found packages that still need attention, such as new and upgraded packages."
	print "Refusing to build binary based on incomplete dependancy data."
	exit(2)

# These must exist on one line only

new_use = xpak.getitem(new_xpak_index, 'USE')
if new_use is not None:
	new_use = ' '.join(new_use.strip().splitlines())
else:
	new_use = ''

new_pdepend = xpak.getitem(new_xpak_index, 'PDEPEND')
if new_pdepend is not None:
	new_pdepend = ' '.join(new_pdepend.strip().splitlines())
else:
	new_pdepend = ''

new_rdepend = xpak.getitem(new_xpak_index, 'RDEPEND')
if new_rdepend is not None:
	new_rdepend = ' '.join(new_rdepend.strip().splitlines())
else:
	new_rdepend = ''

new_depend = ' '.join((new_rdepend + ' ' + new_pdepend + ' ' + strict_depend).strip().splitlines())

old_ebuild = xpak.getitem(new_xpak_index, package+'.ebuild').strip()

existing_group = None
new_group = None
for i, group in enumerate(group_list):
	if new_use in group['use_combos']:
		existing_group = i
		break

if existing_group is None:
	new_ebuild_name = generate_new_ebuild_name(package_name+'-binpkg', package_version, group_list)
	new_group = {'use_combos': [new_use], 'depend_combos': [new_depend], 'ebuild': 'bin-'+category+'/'+new_ebuild_name}
	group_list.append(new_group)
else:
	if new_depend not in group_list[existing_group]['depend_combos']:
		group_list[existing_group]['depend_combos'].append(new_depend)
		new_ebuild_name = generate_new_ebuild_name(package_name+'-binpkg', package_version, group_list)
	else:
		print 'Error: binary package already exists'
		exit(2)

new_spec = build_spec(group_list)
new_use_check_code = build_use_check_code(new_use)

if not os.path.exists(ebin_ebuild_overlay+'/bin-'+category+'/'):
	os.mkdir(ebin_ebuild_overlay+'/bin-'+category+'/')
if not os.path.exists(ebin_ebuild_overlay+'/bin-'+category+'/'+package_name+'-binpkg/'):
	os.mkdir(ebin_ebuild_overlay+'/bin-'+category+'/'+package_name+'-binpkg/')
if not os.path.exists(ebin_ebuild_overlay+'/'+category+'/'):
	os.mkdir(ebin_ebuild_overlay+'/'+category+'/')
if not os.path.exists(ebin_ebuild_overlay+'/'+category+'/'+package_name+'/'):
	os.mkdir(ebin_ebuild_overlay+'/'+category+'/'+package_name+'/')
skel_ebuild_index = open(ebin_lib+'/ebuild/ebin-index-skel.ebuild', 'r');
new_ebuild_index_path = ebin_ebuild_overlay+'/'+category+'/'+package_name+'/'+package+'.ebuild'
new_ebuild_index = open(new_ebuild_index_path, 'w');
skel_ebuild_binary = open(ebin_lib+'/ebuild/ebin-index-skel.ebuild', 'r');
new_ebuild_binary_path = ebin_ebuild_overlay+'/bin-'+category+'/'+package_name+'-binpkg/'+new_ebuild_name+'.ebuild'
new_ebuild_binary = open(new_ebuild_binary_path, 'w');

for line in skel_ebuild_index:
	line = line.replace('%%P%%', package)
	line = line.replace('%%SPEC%%', new_spec)
	line = line.replace('%%EBUILD%%', old_ebuild)
	new_ebuild_index.write(line)

for line in skel_ebuild_binary:
	line = line.replace('%%P%%', package)
	line = line.replace('%%SRC_URI%%', 'http://neuvoo.org/neuvoo/distfiles/'+category+'/'+new_ebuild_name+'.tbz2')
	line = line.replace('%%USE_CHECK%%', new_use_check_code)
	line = line.replace('%%DEPEND%%', new_depend)
	line = line.replace('%%STRICT_DEPEND%%', strict_depend)
	line = line.replace('%%EBUILD%%', old_ebuild)
	new_ebuild_binary.write(line)

skel_ebuild_index.close()
new_ebuild_index.close()
skel_ebuild_binary.close()
new_ebuild_binary.close()

import subprocess
if subprocess.call(['ebuild', new_ebuild_index_path, 'manifest']) is not 0:
	print "Manifest failed"
	exit(2)

if subprocess.call(['ebuild', new_ebuild_binary_path, 'manifest']) is not 0:
	print "Manifest failed"
	exit(2)
